# 854. 相似度为 K 的字符串
- 如果可以通过将 A 中的两个小写字母精确地交换位置 K 次得到与 B 相等的字符串，我们称字符串 A 和 B 的相似度为 K（K 为非负整数）。
给定两个字母异位词 A 和 B ，返回 A 和 B 的相似度 K 的最小值。

- Example 1 输入：A1 = "aabc", B1 = "abca"   输出：2
- Example 2 输入：A2 = "abac", B2 = "baca"   输出：2
- Example 3 输入：A3 = "abcdefabcdefabcdef", B3 = "acccafdeaddbbefbef",  输出： 8

## 思路
- 预处理
  删除 字符串中的交叉项 if A[i] == B[i] for any i 。 比如将 A1 和 B1 中的第一子字母a 删除，从而缩小问题规模
- 封闭字串
  针对原来字符串中的某几位，组成两个新的字符串。如果这两个新的子字符串是交叉相似的，则称这个子字符串是封闭子字符串。进一步地，如果对于给定的封闭字串，不能将其划分成两个封闭字串，那么这两个字串称为最小封闭字串。
  比如： example 1 中，第{1，2}位组成一个最小封闭字串； example 3 中 将{2，9，13}位抽取出，得到两个字串 bca 和 cab, 也是最小封闭字串。
- 相似度
  存在一定引理（并未证明，只是感觉应该成立）
   1. 如果一对字符串s1,s2是最小封闭字串，那么 相似度sim(s1,s2) = len(s1) - 1。
      证明方法：反正法+构造。首先，显然得到上界 sim(s1,s2) <= len(s1) - 1. 反证，如果sim(s1,s2) < len(s1) - 1， 必定可以构造一个更小的封闭字串。具 
      体的构造思路可以见下述的“封闭环”图
   2. 如果一对字符串s1,s2 可以划分成 t 个 封闭字串，那么 sim(s1,s2) <= len(s1) - t。
      1的直接推论
   3. 如果一对字符串最多可以划分成 t 个 封闭字串，那么 sim(s1,s2) == len(s1) - t。
      证明: 反证法。假设 存在某种交换方式 使得sim < len(s1) - t, 那么由这种交换方式 来 构造封闭字串，再论证最小封闭字串数量必定大于t，矛盾。
   
   - 因此，寻找字符串的相似度，变为寻找字符串的一个划分，使得每个字串都是最小封闭字串且划分数量最大。
   - 挑战，字符串的划分有多种可能性！
   
